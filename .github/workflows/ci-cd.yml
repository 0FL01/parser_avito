name: CI/CD Pipeline

on:
  push:
    branches: [ dev ] 
  pull_request:
    branches: [ dev ] 

env:
  # Имя вашего образа Docker
  DOCKER_IMAGE_NAME: avito-parser
  # Ваш логин на Docker Hub из секретов GitHub
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  # Версия образа, используем SHA коммита для уникальности
  VERSION: ${{ github.sha }}
  # Короткая версия SHA (если нужна, сейчас совпадает с полной)
  # SHORT_VERSION: ${{ github.sha }} # Можно использовать github.sha:7 для короткого хеша

jobs:
  test:
    # Задание для запуска юнит/интеграционных тестов кода Python
    runs-on: ubuntu-latest
    env:
      # Переменные окружения для тестов, получаемые из секретов
      URL_AVITO: ${{ secrets.URL_AVITO }}
      CHAT_ID_TG: ${{ secrets.CHAT_ID_TG }}
      TG_TOKEN: ${{ secrets.TG_TOKEN }}
      NUM_ADS_AVITO: ${{ secrets.NUM_ADS_AVITO }}
      FREQ_AVITO: ${{ secrets.FREQ_AVITO }}
      KEYS_AVITO: ${{ secrets.KEYS_AVITO }}
      MAX_PRICE_AVITO: ${{ secrets.MAX_PRICE_AVITO }}
      MIN_PRICE_AVITO: ${{ secrets.MIN_PRICE_AVITO }}
      GEO_AVITO: ${{ secrets.GEO_AVITO }}
      PROXY_AVITO: ${{ secrets.PROXY_AVITO }}
      PROXY_CHANGE_IP_AVITO: ${{ secrets.PROXY_CHANGE_IP_AVITO }}
      NEED_MORE_INFO_AVITO: ${{ secrets.NEED_MORE_INFO_AVITO }}
      DEBUG_MODE_AVITO: ${{ secrets.DEBUG_MODE_AVITO }}
      FAST_SPEED_AVITO: ${{ secrets.FAST_SPEED_AVITO }}
      KEYS_BLACK_AVITO: ${{ secrets.KEYS_BLACK_AVITO }}
      MAX_VIEW_AVITO: ${{ secrets.MAX_VIEW_AVITO }}
      # Добавляем PYTHONPATH, чтобы pytest мог найти модули приложения
      PYTHONPATH: ${{ github.workspace }}
    steps:
      # 1. Получаем код из репозитория
      - uses: actions/checkout@v3

      # 2. Настраиваем окружение Python
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Cache pip dependencies
        uses: actions/cache@v4 # Обновляем версию action
        with:
          path: ~/.cache/pip # Путь к кэшу pip
            # Ключ кэша включает ОС, версию Python и хеш requirements.txt
            # При изменении requirements.txt кэш будет пересоздан
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
              ${{ runner.os }}-pip-

      # 3. Устанавливаем зависимости проекта и тестовые библиотеки
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install pytest pytest-cov pytest-mock # Устанавливаем pytest и его плагины

      # 4. Запускаем тесты с помощью pytest и собираем отчет о покрытии
      - name: Run tests
        run: |
          pytest tests/ --cov=./ --cov-report=xml

      # Шаг для загрузки отчета о покрытии как артефакта
      - name: Upload coverage report
        uses: actions/upload-artifact@v4 # Обновляем версию action
        with:
          name: coverage-report # Имя артефакта
          path: coverage.xml # Путь к файлу отчета
          if-no-files-found: error # Завершить с ошибкой, если файл не найден

  build-and-test-container:
    # Задание для сборки Docker-образа и его тестового запуска
    needs: test # Запускается только после успешного выполнения задания 'test'
    runs-on: ubuntu-latest
    steps:
      # 1. Получаем код из репозитория
      - uses: actions/checkout@v3

      # 2. Настраиваем Docker Buildx для сборки образов
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # 3. Логинимся в Docker Hub для последующей отправки образа
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }} # Используйте токен доступа Docker Hub

      # 4. Собираем Docker образ, но пока не отправляем (push: false)
      # load: true загружает образ в локальный Docker демон раннера для теста
      - name: Build Docker image
        id: build_image # Даем ID шагу, чтобы ссылаться на тег образа
        uses: docker/build-push-action@v4
        with:
          context: .
          push: false
          load: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.VERSION }}
          # Опционально: добавляем тег 'latest' для dev ветки
          # tags: |
          #   ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.VERSION }}
          #   ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:latest

      # 5. Запускаем тест контейнера (ваш существующий скрипт)
      - name: Test Docker container
        id: test_container # Даем ID шагу для проверки его статуса
        run: |
          #!/bin/bash
          set -e # Выход при первой ошибке

          CONTAINER_NAME="avito-parser-test-${GITHUB_RUN_ID}"
          # Используем тег, сгенерированный шагом сборки (хотя он и так известен через env.VERSION)
          IMAGE_TAG="${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.VERSION }}"
          ENV_FILE=".env.test"
          SUCCESS_PATTERN="Парсинг завершен"
          TIMEOUT_SECONDS=180 # Таймаут 3 минуты
          CHECK_INTERVAL=10 # Интервал проверки логов

          # Создаем .env файл для тестового контейнера
          echo "Creating $ENV_FILE..."
          echo 'URL_AVITO=${{ secrets.URL_AVITO }}' > $ENV_FILE
          echo 'CHAT_ID_TG=${{ secrets.CHAT_ID_TG }}' >> $ENV_FILE
          echo 'TG_TOKEN=${{ secrets.TG_TOKEN }}' >> $ENV_FILE
          echo 'NUM_ADS_AVITO=${{ secrets.NUM_ADS_AVITO }}' >> $ENV_FILE
          echo 'FREQ_AVITO=${{ secrets.FREQ_AVITO }}' >> $ENV_FILE
          echo 'KEYS_AVITO=${{ secrets.KEYS_AVITO }}' >> $ENV_FILE
          echo 'MAX_PRICE_AVITO=${{ secrets.MAX_PRICE_AVITO }}' >> $ENV_FILE
          echo 'MIN_PRICE_AVITO=${{ secrets.MIN_PRICE_AVITO }}' >> $ENV_FILE
          echo 'GEO_AVITO=${{ secrets.GEO_AVITO }}' >> $ENV_FILE
          echo 'PROXY_AVITO=${{ secrets.PROXY_AVITO }}' >> $ENV_FILE
          echo 'PROXY_CHANGE_IP_AVITO=${{ secrets.PROXY_CHANGE_IP_AVITO }}' >> $ENV_FILE
          echo 'NEED_MORE_INFO_AVITO=${{ secrets.NEED_MORE_INFO_AVITO }}' >> $ENV_FILE
          echo 'DEBUG_MODE_AVITO=${{ secrets.DEBUG_MODE_AVITO }}' >> $ENV_FILE
          echo 'FAST_SPEED_AVITO=${{ secrets.FAST_SPEED_AVITO }}' >> $ENV_FILE
          # Исправлено имя переменной секрета на KEYS_BLACK_AVITO
          echo 'keys_black=${{ secrets.KEYS_BLACK_AVITO }}' >> $ENV_FILE
          echo 'MAX_VIEW_AVITO=${{ secrets.MAX_VIEW_AVITO }}' >> $ENV_FILE
          echo "$ENV_FILE created."

          # Функция очистки для остановки/удаления контейнера и файла .env
          cleanup() {
            echo "Cleaning up test container $CONTAINER_NAME..."
            docker stop $CONTAINER_NAME || echo "Container $CONTAINER_NAME was not running."
            docker rm $CONTAINER_NAME || echo "Container $CONTAINER_NAME could not be removed (may already be gone)."
            rm -f $ENV_FILE
            echo "Cleanup finished."
          }
          # Регистрируем cleanup для выполнения при выходе из скрипта (успешном или нет)
          trap cleanup EXIT

          # Запускаем контейнер в фоновом режиме (-d)
          echo "Starting container $CONTAINER_NAME from image $IMAGE_TAG..."
          docker run -d --name $CONTAINER_NAME --env-file $ENV_FILE $IMAGE_TAG

          # Ждем появления сообщения об успехе в логах или таймаута/падения контейнера
          echo "Waiting up to $TIMEOUT_SECONDS seconds for container to produce '$SUCCESS_PATTERN' in logs..."
          SECONDS=0
          SUCCESS=false
          while [ $SECONDS -lt $TIMEOUT_SECONDS ]; do
            # Проверяем, работает ли еще контейнер
            if ! docker ps -q -f name=^/${CONTAINER_NAME}$; then
              echo "Error: Container $CONTAINER_NAME stopped unexpectedly."
              echo "--- Container Logs ---"
              docker logs $CONTAINER_NAME || echo "Could not retrieve logs for stopped container."
              echo "----------------------"
              exit 1 # Выход с ошибкой
            fi

            # Проверяем логи на наличие паттерна успеха
            # grep -F ищет точную строку, -q подавляет вывод
            if docker logs $CONTAINER_NAME 2>&1 | grep -q -F "$SUCCESS_PATTERN"; then
              echo "Success: Found '$SUCCESS_PATTERN' in logs."
              echo "--- Container Logs (Last 20 lines) ---"
              docker logs $CONTAINER_NAME | tail -n 20
              echo "--------------------------------------"
              SUCCESS=true
              break # Выход из цикла при успехе
            fi

            sleep $CHECK_INTERVAL
            SECONDS=$((SECONDS + CHECK_INTERVAL))
            # Исправлено отображение текущего времени ожидания
            echo "Still waiting... (${SECONDS}/${TIMEOUT_SECONDS} seconds)"
          done

          # Проверяем, вышли ли из цикла по успеху или по таймауту
          if [ "$SUCCESS" = false ]; then
            echo "Error: Timeout ($TIMEOUT_SECONDS seconds) reached waiting for '$SUCCESS_PATTERN'."
            echo "--- Container Logs ---"
            docker logs $CONTAINER_NAME || echo "Could not retrieve logs for running container."
            echo "----------------------"
            exit 1 # Выход с ошибкой
          fi

          # Если успешно, cleanup выполнится через trap. Выходим с кодом 0.
          exit 0

      # 6. Отправляем (push) Docker образ в Docker Hub ТОЛЬКО если тест контейнера прошел успешно
      - name: Push Docker image
        # Условие: выполняется только если предыдущий шаг (test_container) завершился успешно
        if: success()
        uses: docker/build-push-action@v4
        with:
          # Контекст и Dockerfile указывать не нужно, т.к. мы пушим уже собранный образ
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.VERSION }}
          # Опционально: добавляем тег 'latest' для dev ветки
          # tags: |
          #   ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.VERSION }}
          #   ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:latest

  deploy:
    # Задание для деплоя приложения на сервер
    needs: build-and-test-container # Запускается только после успеха 'build-and-test-container'
    runs-on: ubuntu-latest
    environment: dev
    steps:
      # 1. Checkout нужен для использования actions, например, ssh-key-action
      - uses: actions/checkout@v3

      # 2. Устанавливаем SSH ключ для доступа к серверу
      - name: Install SSH key
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          known_hosts: 'placeholder' # Достаточно для StrictHostKeyChecking=no

      # 3. Выполняем команды на удаленном сервере для деплоя
      - name: Deploy to server
        run: |
          # Команда SSH для подключения к серверу и выполнения команд деплоя
          # Используем StrictHostKeyChecking=no, т.к. known_hosts у нас placeholder
          # Замените <your_server_ip_or_domain> на IP или домен вашего сервера
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "
            # Создаем директорию для приложения, если ее нет
            mkdir -p ${{ secrets.APP_LOCATION }} && \
            cd ${{ secrets.APP_LOCATION }} && \
            # Создаем .env файл на сервере со всеми секретами
            echo 'URL_AVITO=${{ secrets.URL_AVITO }}' > .env && \
            echo 'CHAT_ID_TG=${{ secrets.CHAT_ID_TG }}' >> .env && \
            echo 'TG_TOKEN=${{ secrets.TG_TOKEN }}' >> .env && \
            echo 'NUM_ADS_AVITO=${{ secrets.NUM_ADS_AVITO }}' >> .env && \
            echo 'FREQ_AVITO=${{ secrets.FREQ_AVITO }}' >> .env && \
            echo 'KEYS_AVITO=${{ secrets.KEYS_AVITO }}' >> .env && \
            echo 'MAX_PRICE_AVITO=${{ secrets.MAX_PRICE_AVITO }}' >> .env && \
            echo 'MIN_PRICE_AVITO=${{ secrets.MIN_PRICE_AVITO }}' >> .env && \
            echo 'GEO_AVITO=${{ secrets.GEO_AVITO }}' >> .env && \
            echo 'PROXY_AVITO=${{ secrets.PROXY_AVITO }}' >> .env && \
            echo 'PROXY_CHANGE_IP_AVITO=${{ secrets.PROXY_CHANGE_IP_AVITO }}' >> .env && \
            echo 'NEED_MORE_INFO_AVITO=${{ secrets.NEED_MORE_INFO_AVITO }}' >> .env && \
            echo 'DEBUG_MODE_AVITO=${{ secrets.DEBUG_MODE_AVITO }}' >> .env && \
            echo 'FAST_SPEED_AVITO=${{ secrets.FAST_SPEED_AVITO }}' >> .env && \
            echo 'keys_black=${{ secrets.KEYS_BLACK_AVITO }}' >> .env && \
            echo 'MAX_VIEW_AVITO=${{ secrets.MAX_VIEW_AVITO }}' >> .env && \
            # Создаем docker-compose.yml на сервере
            echo 'version: \"3.8\"' > docker-compose.yml && \
            echo 'services:' >> docker-compose.yml && \
            echo '  avito-parser:' >> docker-compose.yml && \
            echo '    image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.VERSION }}' >> docker-compose.yml && \
            echo '    container_name: avito-parser' >> docker-compose.yml && \
            echo '    restart: unless-stopped' >> docker-compose.yml && \
            echo '    env_file: .env' >> docker-compose.yml && \
            # Логинимся в Docker Hub на сервере (если образ приватный)
            # echo '${{ secrets.DOCKERHUB_TOKEN }}' | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin && \
            # Обновляем образ из Docker Hub
            docker compose pull && \
            # Останавливаем и удаляем старый контейнер (если запущен)
            docker compose down || true && \
            # Запускаем новый контейнер в фоновом режиме
            docker compose up -d && \
            # Показываем логи нового контейнера для проверки
            echo '--- Deployment logs ---' && \
            docker logs avito-parser --tail 50
          "